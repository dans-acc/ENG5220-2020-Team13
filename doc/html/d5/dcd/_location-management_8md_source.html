<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BeeSafe Project: doc/wiki/Location-management.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../beeSmall.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BeeSafe Project
   &#160;<span id="projectnumber">v1.0</span>
   </div>
   <div id="projectbrief">Low-cost tracking device.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d5/dcd/_location-management_8md.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">doc/wiki/Location-management.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../d5/dcd/_location-management_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;This page highlights the structure employed for defining virtual fences.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;# Fences</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;Fences are defined according to the following hierarchical structure:</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;![Fence, RoundFence and PolyFence structure.](https://github.com/itsBelinda/ENG5220-2020-Team13/blob/master/doc/media/Fence_Structure.png)</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;This was done due to each device account possessing numerous virtual fences. With respect to the implementations:</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;* Fence.h / .cpp defines common attributes i.e. whether the fence is regarded as being safe (the device can be removed), times, and the name.</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;* RoundFence.h / .cpp defines a circular virtual fence around a centre point (latitude, longitude and radius). It does not however take into account the curvature of Earth.</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;* PolyFence.h / .cpp defines polygon fences with numerous points. The implementation is based on the work published on [Determining Whether A Point Is Inside A Complex Polygon](http://alienryderflex.com/polygon/?fbclid=IwAR1iLUkzQZnRRCWvPyUjvrYXU6W259FduDmq8NhDPSHMaUAtOmUnE_HEoAA) - which, once again, does not consider the curvature of the Earth.</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;Each instance is responsible for serialising JSON elements that represent the fence (sub-classes), first invoke the super-class serialisation then build on this in the extended (overridden) functions. However, they are created using the [AccountBuilder](https://github.com/itsBelinda/ENG5220-2020-Team13/wiki/Account-Management).</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;**It should be noted that not taking the curvature into consideration only affects extremely large fences (areas larger than Texas).**</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;## Fence.h / .cpp</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;Not only does the Fence super-class define common attributes, but it also handles common operations such as determining whether the device needs to be present in the fence at a given time.</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;```cpp</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;bool Fence::isInTime(const std::time_t &amp;time) {</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    // Extract information from system time.</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    std::tm time_tm = *std::localtime(&amp;time);</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    auto iter = week.find(time_tm.tm_wday);</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    // Check if time information exists.</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    if (iter == week.end()) {</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        return true;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    } else if (iter-&gt;second.empty()) {</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        return true;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    }</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    // Iterate through days list of from and to times.</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    auto &amp;dayTimes = iter-&gt;second;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    for (const std::pair&lt;std::tm, std::tm&gt; &amp;dayTime : dayTimes) {</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        // If time is before from time, we are not present.</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;        if (time_tm.tm_hour &lt; dayTime.first.tm_hour) {</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;            return false;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        } else if (time_tm.tm_hour == dayTime.first.tm_hour) {</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;            if (time_tm.tm_min &lt; dayTime.first.tm_min) {</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;                return false;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            }</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        }</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        // If the time is after the to time, we are not present.</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        if (time_tm.tm_hour &gt; dayTime.second.tm_hour) {</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;            return false;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        } else if (time_tm.tm_hour == dayTime.second.tm_hour) {</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;            if (time_tm.tm_min &gt; dayTime.second.tm_min) {</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;                return false;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            }</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        }</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    }</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    // By default the user is within the fence.</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    return true;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;}</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;```</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;This is achieved by comparing the current time of the device (using ```*std::localtime(&amp;time);```)  against the serialised times represented by the ```const std::map&lt;int, std::vector&lt;std::pair&lt;std::tm, std::tm&gt;&gt;&gt; &amp;week```, where a day (the map key) maps onto a vector containing the starting and ending times (```std::pair&lt;std::tm, std::tm&gt;```). Moreover, in the event the said Fence map is empty, the function returns true (indicating that the device is indeed present in the fence at that particular time).</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;## RoundFence.h / .cpp</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;As stated, the round fence represents the fence defined around some coordinate (latitude, longitude). Thus, a determining whether the device is geographically located within can be achieved using simple geometry:</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;```cpp</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;bool RoundFence::isInLocation(std::pair&lt;double, double&gt; &amp;latLng)</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;{</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    double distance = std::sqrt((latLng.first - this-&gt;longitude) * (latLng.first - this-&gt;latitude)</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;                                + (latLng.second - this-&gt;longitude) * (latLng.second - this-&gt;longitude));</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    return distance &lt;= radius;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;}</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;```</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;Where the ```std::pair&lt;double, double&gt; &amp;latLng``` represents the device coordinates (```latLng.first``` and ```latLng.second``` represent the latitude and longitude, respectively); passed by the Monitor.h / Monitor.cpp (monitor thread).</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;## PolyFence.h / .cpp</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;Finally, polygon fences are represented using a vector of pairs i.e. ```std::vector&lt;std::pair&lt;double, double&gt;&gt; coordinates```; where each pair represents coordinates as follows: </div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;* ```latLng.first``` and ```latLng.second``` represent the latitude and longitude, respectively.</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;### Implementation</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;With respect to the implementation of the algorithm as posited on [Determining Whether A Point Is Inside A Complex Polygon](http://alienryderflex.com/polygon/?fbclid=IwAR1iLUkzQZnRRCWvPyUjvrYXU6W259FduDmq8NhDPSHMaUAtOmUnE_HEoAA), suggested optimisations have been taken into account. Thus, constants associated with the fence are calculated prior to monitoring being carried out i.e. during the initialisation phase of the device. The following code snippet posits the manner by which this is achieved:</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;```cpp</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;void PolyFence::calculateFenceConstants()</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;{</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    // Clear the constants for recalculation.</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    constants.clear();</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    multiples.clear();</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    // If the coordinates are empty, nothing can be done.</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    if (coordinates.empty()) {</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;        return;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    }</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;    // Calculate poly fence constants.</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    unsigned long i, j = coordinates.size() - 1;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    for (i = 0; i &lt; coordinates.size(); ++i) {</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        if (coordinates[i].second == coordinates[j].second) {</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;            constants.push_back(coordinates[i].first);</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;            multiples.push_back(0);</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        } else {</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;            constants.push_back(coordinates[i].first</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                                - (coordinates[i].second * coordinates[j].first)</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                                  / (coordinates[j].second - coordinates[i].second)</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                                + (coordinates[i].second * coordinates[i].first)</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                                  / (coordinates[j].second - coordinates[i].second));</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;            multiples.push_back((coordinates[j].first - coordinates[i].first)</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                                / (coordinates[j].second - coordinates[i].second));</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        }</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        j = i;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    }</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;}</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;```</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;Where determining whether or not the device is within the polygon fence is achieved by utilising the following function, analogous to the one posited by RoundFence.h / .cpp:</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;```cpp</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;bool PolyFence::isInLocation(std::pair&lt;double, double&gt; &amp;latLng)</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;{</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    bool oddNodes = false;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    bool current = coordinates.back().second &gt; latLng.second;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    bool previous;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    // Determines whether or not latitude and longitude are within the fence.</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    for (int i = 0; i &lt; coordinates.size(); ++i) {</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        previous = current;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        current = coordinates[i].second &gt; latLng.second;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        if (current != previous) {</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;            oddNodes ^= latLng.second * multiples[i] + constants[i] &lt; latLng.first;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        }</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    }</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;    return oddNodes;</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;```</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;Functionally, the algorithm compares each side of the polygon against the longitude of the device location. Additionally, a list of nodes are compiled, where each of the nodes represent a point where one side crosses the longitude threshold of the device location. Thus,</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;* If there are an odd number of points (on each side of the location), then device is said to be within the polygon.</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;* If, however, there are an even number of nodes, the device location is outside of the polygon.</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;**Reference:** [Determining Whether A Point Is Inside A Complex Polygon](http://alienryderflex.com/polygon/?fbclid=IwAR1iLUkzQZnRRCWvPyUjvrYXU6W259FduDmq8NhDPSHMaUAtOmUnE_HEoAA)</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;## Displaying Virtual Fences</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;_The following image depicts the defined virtual fences. It should be noted that due to time constraints, the web API backend was not implemented. Thus, the project falls just short of being completed due to the backend missing link for the website [frontend is present and is depicted by the following image]._</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;![Defined virtual fences](https://github.com/itsBelinda/ENG5220-2020-Team13/blob/master/doc/media/Fences.png)</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d5/dcd/_location-management_8md.html">Location-management.md</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
