<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BeeSafe Project: doc/wiki/Communications.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../beeSmall.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BeeSafe Project
   &#160;<span id="projectnumber">v1.0</span>
   </div>
   <div id="projectbrief">Low-cost tracking device.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dc/d06/_communications_8md.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">doc/wiki/Communications.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../dc/d06/_communications_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;The following page highlights various properties surrounding the comms/ package i.e. the communications stack implemented which includes Comms.h / .cpp, UBlox.h / .cpp, and UArt.h / .cpp.</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;# The Communications Interface</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;The communications (or comms) interface is implemented analogous to the ISO networking stack, in which  levels are abstracted from one another; lower levels implement low-level interface code, whilst higher levels implement an API-like interface. The following image depicts the communications stack:</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;![BeeSafePI communications stack.](https://github.com/itsBelinda/ENG5220-2020-Team13/blob/master/doc/media/Communications%20Stack.png)</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;As stated, each level is responsible for a separate task, namely:</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;* The **Comms.h / .cpp** provides a synchronised API interface (via mutex) to the low-level communications code; multiple threads may utilise the communications package simultaneously e.g. Monitor.h / .cpp for monitoring and BeeSafe.h / .cpp for management (downloading updates, accounts, etc.). Moreover, this prevents the need to implement / manage locking of the relatively complex interoperability of the underlying levels, thereby yielding a considerably more coherent implementation / structure. Additionally, locking mechanism aids and protects the underlying stacks finite-state-based implementation (internally, the underlying stack is responsible for entering and leaving a set of read / write states in order to process responses from a command).</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;* **UBlox.h / .cpp** specialises in configuring the underlying device via [AT commands](https://github.com/itsBelinda/ENG5220-2020-Team13/wiki/uBlox-and-CellLocate) in addition reading and writing the said commands via the UART (Universal Asynchronous Receiver/Transmitter) interface. </div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;* Finally, **UArt.h / .cpp** is responsible reading and writing from and to the UART interface, respectively, on a byte level in addition to configuring the serial interface via [termios](http://man7.org/linux/man-pages/man3/termios.3.html).</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;## Implementation</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;The following section addresses implementations with respect to the aforementioned communications stack.</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;### Comms.h / .cpp</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;As stated, the Comms.h / .cpp files are responsible for providing concurrent synchronised access to the underlying interface. Given that only one device exists, attempting to invoke commands concurrently _may_ result in corrupting the UBlox.h / .cpp result buffer (by clearing it or mixing [AT command response formats](https://github.com/itsBelinda/ENG5220-2020-Team13/wiki/uBlox-and-CellLocate)) or aborting pending commands.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;```cpp</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;bool Comms::init()</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;{</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    // Lock and initialise the comms interface.</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    mtx.lock();</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    bool initialised = uBlox.init();</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    mtx.unlock();</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    // Whether or not the comms was successfully initialised.</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    return initialised;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;}</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;```</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;Due to functional dependencies associated with the communications interface, the BeeSafe.h / .cpp manager attempts to initialise the Comms.h / .cpp interface - and in turn the entire stack - three times; the prior code-snippet posits the Comms.h / .cpp initialisation function. In doing so, the entire stack is re-initialised, once again, adopting an all or nothing approach. If, however, the interface fails to initialise, the program is terminated as we are unable to do _anything_.</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;```cpp</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;Comms* BeeSafeManager::initComms()</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;{</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    auto comms = new Comms();</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    // Try numerous times to initialise the comms interface.</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    bool init = false;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    short tries = 0;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    do {</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        // Attempt to initialise the interface.</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        tries++;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        std::cout &lt;&lt; &quot;Comms initialisation attempt &quot; &lt;&lt; tries &lt;&lt; &quot; / &quot; &lt;&lt; INIT_COMMS_TRIES &lt;&lt; &quot;...&quot; &lt;&lt;  std::endl;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        init = comms-&gt;init();</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        if (init) {</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;            break;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        } else {</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;            std::cerr &lt;&lt; &quot;... comms initialisation attempt &quot; &lt;&lt; tries &lt;&lt; &quot; / &quot; &lt;&lt; INIT_COMMS_TRIES &lt;&lt; &quot; failed.&quot; &lt;&lt; std::endl;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        }</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    } while (tries &lt; INIT_COMMS_TRIES);</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    // We failed to initialise the interface.</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    if (!init) {</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        delete comms;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        return nullptr;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    }</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    // Successfully return the comms instance.</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    return comms;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;}</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;```</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;### UBlox.h / .cpp</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;The UBlox.h / .cpp files are arguable the most important files within the communication stack, defining both the commands and the means by which they are interpreted (due to differing formats). First and foremost, however, the UBlox layer is responsible for [configuring the underlying u-Blox device](https://github.com/itsBelinda/ENG5220-2020-Team13/wiki/uBlox-and-CellLocate) during the initialisation phase. During the said phase, the layer performs the following operations, terminating (returning) in the event of a failure at any stage:</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;* First, invoking the UArt.h / .cpp initialisation functions to establish a serial connection with the device. Failing to do so will result in a premature termination (return) of the UBlox initialisation function indicating that the device could not be initialised.</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;* Checking whether the SIM card has been registered. If not, automatic SIM card registration is started.</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;* By definition, successful registration of the SIM card should yield a state in which GPRS is considered to be &#39;attached&#39;. If, however, the command could not be performed (maybe the device is not present?), the function returns i.e. UBlox.h / .cpp failed to communicate with the u-Blox device.</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;* [Establishing an internet connection (PSD)](https://github.com/itsBelinda/ENG5220-2020-Team13/wiki/uBlox-and-CellLocate). </div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;* Setting the message mode to TEXT so that text messages could be sent to any of the defined contacts.</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;* Setting the location scan mode - used for obtaining the location (latitude and longitude) of the device.</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;The following code snippet posits the initialisation function (without the messages printed to the terminal):</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;```cpp</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;bool UBlox::init()</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;{</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    // Initialise the UART device and interface.</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    if (!uArt.init()) {</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        return false;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    }</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    // Check if the SIM has been registered.</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    bool simRegistered = false;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    if (!hasRegistered(simRegistered)) {</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;        return false;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    } else if (!simRegistered) {</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;        if (!startAutoRegistration(simRegistered)) {</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;            return false;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        } else if (!simRegistered) {</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;            return false;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        }</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    }</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;    // Check if GPRS is attached.</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    bool gprsAttached = false;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    if (!hasGPRS(gprsAttached)) {</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        return false;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    }</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    // Check if there is an internet connection.</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    bool psdConnected = false;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    std::string psdUrc;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;    if (!hasPSD(psdConnected)) {</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        return false;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;    } else if (!psdConnected || !gprsAttached) {</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        if (!connectPSD(psdConnected, psdUrc) || !psdConnected) {</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            return false;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;        }</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    }</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    // Configure the sending of messages.</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    if (!setSendMessageMode(SEND_TEXT_MODE_TEXT)) {</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        return false;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    }</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    // Configure the scan mode for obtaining the location.</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    if (!setLocationScanMode(LOC_SCAN_MODE_DEEP)) {</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        return false;</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    }</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    return true;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;}</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;```</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;#### Reading and Writing Commands</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;Writing AT commands to the device is relatively straight forward - the underlying UArt.h / .cpp &#39;.writeNext(...)&#39; function is invoked followed by a &#39;readNext(...)&#39; in order to obtain the echo.</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;```cpp</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;ssize_t UBlox::writeCommand(const char *command)</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;{</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    // Write the command to the device.</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    ssize_t rc = uArt.writeNext(command);</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;    if (rc == -1) {</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        return -1;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    }</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;    // Read the raw echo response and check lengths to determine if echoed.</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;    rc = readRawResponse(RX_TIMEOUT_ECHO);</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    if (rc == -1) {</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        return -1;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    }</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    return strlen(command) == rc;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;}</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;```</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;Given that there is a single device, responses are read into a common buffer in order to preserve memory. This is achieved by one of the two following functions:</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;```cpp</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;ssize_t UBlox::readRawResponse(int timeoutMs)</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;{</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    // Clear the buffer and read the response from the device.</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    clearResponseBuff();</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    return uArt.readNext(buffer, AT_CMD_BUFF_LEN, timeoutMs);</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;}</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;```</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;or</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;```cpp</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;const char* UBlox::readStatusResponse(bool crlf)</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;{</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    // Occasionally there are preceding \r\n; read and discard.</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;    ssize_t rc = -1;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    if (crlf) {</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        rc = readRawResponse(RX_TIMEOUT);</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        if (rc != 2) {</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;            return nullptr;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        }</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    }</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    // Generically read the device response and attempt to resolve the status.</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    rc = readRawResponse(RX_TIMEOUT_STATUS);</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    if (rc == -1) {</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        return nullptr;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    }</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;    return checkResponseBuffStatus();</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;}</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;```</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;The former merely clears (sets all elements to null terminators &#39;\0&#39;) the buffer and reads the raw response, leaving the contents to be interpreted by the invoking function. The latter, however, implicitly invokes the former function with the addition of attempting to resolve the response ([OK, ERROR, or ABORTED](https://github.com/itsBelinda/ENG5220-2020-Team13/wiki/uBlox-and-CellLocate)), consequently retuning a pointer to the state or nullptr in the event the status could not be resolved.</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;### UArt.h / .cpp</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;Finally, at the bottom of the stack, the UArt.h / .cpp files are responsible for managing the serial connection with the device. Thus, it implements the means by which commands are written to and read from the device.</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;First and foremost, the serial interface is initialised i.e. the device path (/dev/ttyS0) is opened and shortly configured using termios. </div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;* Due to varying timeout durations associated with each command, VMIN and VTIME equal 0, thereby creating a non-blocking serial connection.</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;#### Reading</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;Instead, commands are read utilising a polling based on the works posited on [Serial C and The Raspberry PI](https://www.i-programmer.info/programming/cc/10027-serial-c-and-the-raspberry-pi.html). </div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;While the interface _does_ implement &#39;readExpected(...)&#39; function for reading until blocks of known sizes, it is not utilised due to surrounding uncertainties of the environment (a premature ABORTED may be returned instead). </div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;Thus, exploiting the format according to which responses are returned (\r\n at the end of each response), the &#39;readNext(...)&#39;, the function permits variable sized blocks to be read.</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;```cpp</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;ssize_t UArt::readNext(char * const resultBuffer, const size_t resultBufferLen,</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;                       const int timeoutMs)</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;{</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    // Check that the device is present.</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    if (device == -1) {</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        return -1;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    }</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    // The number of bytes that have been peeked and read.</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    size_t bytesPeeked = 0;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    ssize_t bytesRead = 0;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    // The next and last read indexes.</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    size_t nextReadIndex = 0;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    size_t lastReadIndex = 0;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    // The last read character.</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    char lastReadChar;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    // Timeout pause.</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    struct timespec timeoutPause = {0};</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;    timeoutPause.tv_sec = timeoutMs / 1000;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    timeoutPause.tv_nsec = (timeoutMs % 1000) * 1000000L;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    // Keep reading the buffer until crlf.</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    for (;;) {</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        // If the buffer has been exceeded, return -1.</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        lastReadIndex = nextReadIndex;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        if (lastReadIndex &gt;= resultBufferLen) {</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;            return -1;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        }</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        // If there are no characters within the buffer, sleep.</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        ioctl(device, FIONREAD, &amp;bytesPeeked);</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        if (bytesPeeked &lt;= 0 &amp;&amp; nanosleep(&amp;timeoutPause, nullptr)) {</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;            return -1;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        }</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        // Read in a single character from the serial buffer.</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        bytesRead = read(device, &amp;lastReadChar, 1);</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        if (bytesRead == -1) {</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;            return -1;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        } else if (bytesRead == 1) {</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;            // Write the character to the buffer, check if &#39;\n&#39;.</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;            resultBuffer[nextReadIndex++] = lastReadChar;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;            if (lastReadChar == &#39;\n&#39;) {</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                break;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            }</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            // Skip to the next character.</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            continue;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;        }</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;        // If no new bytes have been read and we have timed out, return.</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        if (nextReadIndex == lastReadIndex) {</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            return -1;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;        }</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    }</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    // Return the number of characters that have been read.</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    return nextReadIndex;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;}</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;```</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;Functionally, the &#39;readNext(...)&#39; utilises C&#39;s nanosleep for inter-byte timeouts to sleep the thread until it is awoken due to the device responding with bytes; this state is entered in the event all characters have been read from the underlying Linux / device buffer (any bytes within the buffer will be immediately processed). Thus, the algorithm is functionally analogous to polling with the said nanosleep function providing the means by which inter-character timeouts are achieved. </div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;#### Writing</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;**Assuming that the command conforms to the defined format i.e. ending in \r, the command can be written to the device by invoking the following function.**</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;```cpp</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;ssize_t UArt::writeNext(const char *command)</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;{</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    if (device != -1 &amp;&amp; tcflush(device, TCIFLUSH) == 0) {</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        return write(device, command, strlen(command) + 1);</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;    }</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    return -1;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;}</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;```</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;Functionally, the function ensures that the device is present, flushes the data already written to the device and writes the command to the underlying device buffer.</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;## Running Program</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;![The program executing successfully.](https://github.com/itsBelinda/ENG5220-2020-Team13/blob/master/doc/media/Running_Program.png)</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../dc/d06/_communications_8md.html">Communications.md</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
