<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BeeSafe Project: Communications</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../beeSmall.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BeeSafe Project
   &#160;<span id="projectnumber">v1.0</span>
   </div>
   <div id="projectbrief">Low-cost tracking device.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dc/d46/md_doc_wiki__communications.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Communications </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The following page highlights various properties surrounding the comms/ package i.e. the communications stack implemented which includes <a class="el" href="../../d1/dd7/_comms_8h.html">Comms.h</a> / .cpp, <a class="el" href="../../d2/d67/_u_blox_8h.html">UBlox.h</a> / .cpp, and <a class="el" href="../../d7/d62/_u_art_8h.html">UArt.h</a> / .cpp.</p>
<h1>The Communications Interface</h1>
<p>The communications (or comms) interface is implemented analogous to the ISO networking stack, in which levels are abstracted from one another; lower levels implement low-level interface code, whilst higher levels implement an API-like interface. The following image depicts the communications stack:</p>
<div class="image">
<img src="https://github.com/itsBelinda/ENG5220-2020-Team13/blob/master/doc/media/Communications%20Stack.png" alt="BeeSafePI communications stack."/>
</div>
<p>As stated, each level is responsible for a separate task, namely:</p><ul>
<li>The <b><a class="el" href="../../d1/dd7/_comms_8h.html">Comms.h</a> / .cpp</b> provides a synchronised API interface (via mutex) to the low-level communications code; multiple threads may utilise the communications package simultaneously e.g. <a class="el" href="../../dd/d29/_monitor_8h.html">Monitor.h</a> / .cpp for monitoring and <a class="el" href="../../d7/db3/_bee_safe_8h.html">BeeSafe.h</a> / .cpp for management (downloading updates, accounts, etc.). Moreover, this prevents the need to implement / manage locking of the relatively complex interoperability of the underlying levels, thereby yielding a considerably more coherent implementation / structure. Additionally, locking mechanism aids and protects the underlying stacks finite-state-based implementation (internally, the underlying stack is responsible for entering and leaving a set of read / write states in order to process responses from a command).</li>
<li><b><a class="el" href="../../d2/d67/_u_blox_8h.html">UBlox.h</a> / .cpp</b> specialises in configuring the underlying device via <a href="https://github.com/itsBelinda/ENG5220-2020-Team13/wiki/uBlox-and-CellLocate">AT commands</a> in addition reading and writing the said commands via the UART (Universal Asynchronous Receiver/Transmitter) interface.</li>
<li>Finally, <b><a class="el" href="../../d7/d62/_u_art_8h.html">UArt.h</a> / .cpp</b> is responsible reading and writing from and to the UART interface, respectively, on a byte level in addition to configuring the serial interface via <a href="http://man7.org/linux/man-pages/man3/termios.3.html">termios</a>.</li>
</ul>
<h2>Implementation</h2>
<p>The following section addresses implementations with respect to the aforementioned communications stack. </p><h3><a class="el" href="../../d1/dd7/_comms_8h.html">Comms.h</a> / .cpp</h3>
<p>As stated, the <a class="el" href="../../d1/dd7/_comms_8h.html">Comms.h</a> / .cpp files are responsible for providing concurrent synchronised access to the underlying interface. Given that only one device exists, attempting to invoke commands concurrently <em>may</em> result in corrupting the <a class="el" href="../../d2/d67/_u_blox_8h.html">UBlox.h</a> / .cpp result buffer (by clearing it or mixing <a href="https://github.com/itsBelinda/ENG5220-2020-Team13/wiki/uBlox-and-CellLocate">AT command response formats</a>) or aborting pending commands.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="../../d8/dcc/class_comms.html#aa0519d3ed2d5bd6aad60101080ac2de7">Comms::init</a>()</div><div class="line">{</div><div class="line">    <span class="comment">// Lock and initialise the comms interface.</span></div><div class="line">    <a class="code" href="../../d8/dcc/class_comms.html#a21df861b1202573e4cd0cb5666d638fe">mtx</a>.lock();</div><div class="line">    <span class="keywordtype">bool</span> initialised = <a class="code" href="../../d8/dcc/class_comms.html#ac64dea134b116147e5441172346dbd6c">uBlox</a>.<a class="code" href="../../da/df6/class_u_blox.html#a34c2f507ff3bbd21b9aea788a015527a">init</a>();</div><div class="line">    <a class="code" href="../../d8/dcc/class_comms.html#a21df861b1202573e4cd0cb5666d638fe">mtx</a>.unlock();</div><div class="line"></div><div class="line">    <span class="comment">// Whether or not the comms was successfully initialised.</span></div><div class="line">    <span class="keywordflow">return</span> initialised;</div><div class="line">}</div></div><!-- fragment --><p> Due to functional dependencies associated with the communications interface, the <a class="el" href="../../d7/db3/_bee_safe_8h.html">BeeSafe.h</a> / .cpp manager attempts to initialise the <a class="el" href="../../d1/dd7/_comms_8h.html">Comms.h</a> / .cpp interface - and in turn the entire stack - three times; the prior code-snippet posits the <a class="el" href="../../d1/dd7/_comms_8h.html">Comms.h</a> / .cpp initialisation function. In doing so, the entire stack is re-initialised, once again, adopting an all or nothing approach. If, however, the interface fails to initialise, the program is terminated as we are unable to do <em>anything</em>.</p>
<div class="fragment"><div class="line"><a class="code" href="../../d8/dcc/class_comms.html">Comms</a>* <a class="code" href="../../d5/d75/class_bee_safe_manager.html#a28306d7ccf7136a6086d666f4ebb6566">BeeSafeManager::initComms</a>()</div><div class="line">{</div><div class="line">    <span class="keyword">auto</span> <a class="code" href="../../d5/d75/class_bee_safe_manager.html#a80b19afbb679d08be14d67a45447f9e1">comms</a> = <span class="keyword">new</span> <a class="code" href="../../d8/dcc/class_comms.html">Comms</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Try numerous times to initialise the comms interface.</span></div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="../../d5/d75/class_bee_safe_manager.html#a2f16b09c454e21c887d14ac5483973cf">init</a> = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordtype">short</span> tries = 0;</div><div class="line">    <span class="keywordflow">do</span> {</div><div class="line"></div><div class="line">        <span class="comment">// Attempt to initialise the interface.</span></div><div class="line">        tries++;</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Comms initialisation attempt &quot;</span> &lt;&lt; tries &lt;&lt; <span class="stringliteral">&quot; / &quot;</span> &lt;&lt; <a class="code" href="../../dd/d20/_bee_safe_8cpp.html#aa5860d80bbb4527d5d2275aacfce65f7">INIT_COMMS_TRIES</a> &lt;&lt; <span class="stringliteral">&quot;...&quot;</span> &lt;&lt;  std::endl;</div><div class="line">        init = <a class="code" href="../../d5/d75/class_bee_safe_manager.html#a80b19afbb679d08be14d67a45447f9e1">comms</a>-&gt;<a class="code" href="../../d8/dcc/class_comms.html#aa0519d3ed2d5bd6aad60101080ac2de7">init</a>();</div><div class="line">        <span class="keywordflow">if</span> (init) {</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;... comms initialisation attempt &quot;</span> &lt;&lt; tries &lt;&lt; <span class="stringliteral">&quot; / &quot;</span> &lt;&lt; <a class="code" href="../../dd/d20/_bee_safe_8cpp.html#aa5860d80bbb4527d5d2275aacfce65f7">INIT_COMMS_TRIES</a> &lt;&lt; <span class="stringliteral">&quot; failed.&quot;</span> &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line"></div><div class="line">    } <span class="keywordflow">while</span> (tries &lt; <a class="code" href="../../dd/d20/_bee_safe_8cpp.html#aa5860d80bbb4527d5d2275aacfce65f7">INIT_COMMS_TRIES</a>);</div><div class="line"></div><div class="line">    <span class="comment">// We failed to initialise the interface.</span></div><div class="line">    <span class="keywordflow">if</span> (!init) {</div><div class="line">        <span class="keyword">delete</span> <a class="code" href="../../d5/d75/class_bee_safe_manager.html#a80b19afbb679d08be14d67a45447f9e1">comms</a>;</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Successfully return the comms instance.</span></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="../../d5/d75/class_bee_safe_manager.html#a80b19afbb679d08be14d67a45447f9e1">comms</a>;</div><div class="line">}</div></div><!-- fragment --><h3><a class="el" href="../../d2/d67/_u_blox_8h.html">UBlox.h</a> / .cpp</h3>
<p>The <a class="el" href="../../d2/d67/_u_blox_8h.html">UBlox.h</a> / .cpp files are arguable the most important files within the communication stack, defining both the commands and the means by which they are interpreted (due to differing formats). First and foremost, however, the <a class="el" href="../../da/df6/class_u_blox.html" title="The class containing module specific functionality for the u-blox GSM module. ">UBlox</a> layer is responsible for <a href="https://github.com/itsBelinda/ENG5220-2020-Team13/wiki/uBlox-and-CellLocate">configuring the underlying u-Blox device</a> during the initialisation phase. During the said phase, the layer performs the following operations, terminating (returning) in the event of a failure at any stage:</p>
<ul>
<li>First, invoking the <a class="el" href="../../d7/d62/_u_art_8h.html">UArt.h</a> / .cpp initialisation functions to establish a serial connection with the device. Failing to do so will result in a premature termination (return) of the <a class="el" href="../../da/df6/class_u_blox.html" title="The class containing module specific functionality for the u-blox GSM module. ">UBlox</a> initialisation function indicating that the device could not be initialised.</li>
<li>Checking whether the SIM card has been registered. If not, automatic SIM card registration is started.</li>
<li>By definition, successful registration of the SIM card should yield a state in which GPRS is considered to be 'attached'. If, however, the command could not be performed (maybe the device is not present?), the function returns i.e. <a class="el" href="../../d2/d67/_u_blox_8h.html">UBlox.h</a> / .cpp failed to communicate with the u-Blox device.</li>
<li><a href="https://github.com/itsBelinda/ENG5220-2020-Team13/wiki/uBlox-and-CellLocate">Establishing an internet connection (PSD)</a>.</li>
<li>Setting the message mode to TEXT so that text messages could be sent to any of the defined contacts.</li>
<li>Setting the location scan mode - used for obtaining the location (latitude and longitude) of the device.</li>
</ul>
<p>The following code snippet posits the initialisation function (without the messages printed to the terminal): </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code" href="../../da/df6/class_u_blox.html#a34c2f507ff3bbd21b9aea788a015527a">UBlox::init</a>()</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// Initialise the UART device and interface.</span></div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="../../da/df6/class_u_blox.html#a034c0463d1c199d094d657c8ebb151e8">uArt</a>.<a class="code" href="../../d9/d88/class_u_art.html#a51adaa81c08d92599768c0303e5abc94">init</a>()) {</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Check if the SIM has been registered.</span></div><div class="line">    <span class="keywordtype">bool</span> simRegistered = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="../../da/df6/class_u_blox.html#a1889c2b9bb6087bc939bd2a27b68623b">hasRegistered</a>(simRegistered)) {</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!simRegistered) {</div><div class="line">        <span class="keywordflow">if</span> (!<a class="code" href="../../da/df6/class_u_blox.html#a2e816e864ebf43743b3f6187e20c2b1f">startAutoRegistration</a>(simRegistered)) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!simRegistered) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Check if GPRS is attached.</span></div><div class="line">    <span class="keywordtype">bool</span> gprsAttached = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="../../da/df6/class_u_blox.html#a4f5a31b4ddda664b255ce3f63e9ffac7">hasGPRS</a>(gprsAttached)) {</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Check if there is an internet connection.</span></div><div class="line">    <span class="keywordtype">bool</span> psdConnected = <span class="keyword">false</span>;</div><div class="line">    std::string psdUrc;</div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="../../da/df6/class_u_blox.html#ae49b51a602a327b5eff5b04d2ccaec20">hasPSD</a>(psdConnected)) {</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!psdConnected || !gprsAttached) {</div><div class="line">        <span class="keywordflow">if</span> (!<a class="code" href="../../da/df6/class_u_blox.html#ac250bd4aea14e09b3a2595c2b8eda18a">connectPSD</a>(psdConnected, psdUrc) || !psdConnected) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Configure the sending of messages.</span></div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="../../da/df6/class_u_blox.html#a12c1042d3bcb503b025927fd53d54243">setSendMessageMode</a>(<a class="code" href="../../d2/d67/_u_blox_8h.html#a4fdc1adf2ea333d6490119160a35401a">SEND_TEXT_MODE_TEXT</a>)) {</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Configure the scan mode for obtaining the location.</span></div><div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="../../da/df6/class_u_blox.html#aabed44fd41e16c9d1a8daba80f3bef06">setLocationScanMode</a>(<a class="code" href="../../d2/d67/_u_blox_8h.html#a5c819e4d40995d2854dc0e2cddd7ddef">LOC_SCAN_MODE_DEEP</a>)) {</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --> <h4>Reading and Writing Commands</h4>
<p>Writing AT commands to the device is relatively straight forward - the underlying <a class="el" href="../../d7/d62/_u_art_8h.html">UArt.h</a> / .cpp '.writeNext(...)' function is invoked followed by a 'readNext(...)' in order to obtain the echo.</p>
<div class="fragment"><div class="line">ssize_t <a class="code" href="../../da/df6/class_u_blox.html#af604d1897a66192bf1c2a11997f2634d">UBlox::writeCommand</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *command)</div><div class="line">{</div><div class="line">    <span class="comment">// Write the command to the device.</span></div><div class="line">    ssize_t rc = <a class="code" href="../../da/df6/class_u_blox.html#a034c0463d1c199d094d657c8ebb151e8">uArt</a>.<a class="code" href="../../d9/d88/class_u_art.html#aad1ddb133fe430a92527584eec2e674f">writeNext</a>(command);</div><div class="line">    <span class="keywordflow">if</span> (rc == -1) {</div><div class="line">        <span class="keywordflow">return</span> -1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Read the raw echo response and check lengths to determine if echoed.</span></div><div class="line">    rc = <a class="code" href="../../da/df6/class_u_blox.html#ab4a7ab4b8922d91e23f273ae160c1bed">readRawResponse</a>(<a class="code" href="../../db/d60/_u_blox_8cpp.html#a55092c0742d15bb08a5ea7db5a25440e">RX_TIMEOUT_ECHO</a>);</div><div class="line">    <span class="keywordflow">if</span> (rc == -1) {</div><div class="line">        <span class="keywordflow">return</span> -1;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> strlen(command) == rc;</div><div class="line">}</div></div><!-- fragment --><p>Given that there is a single device, responses are read into a common buffer in order to preserve memory. This is achieved by one of the two following functions:</p>
<div class="fragment"><div class="line">ssize_t <a class="code" href="../../da/df6/class_u_blox.html#ab4a7ab4b8922d91e23f273ae160c1bed">UBlox::readRawResponse</a>(<span class="keywordtype">int</span> timeoutMs)</div><div class="line">{</div><div class="line">    <span class="comment">// Clear the buffer and read the response from the device.</span></div><div class="line">    <a class="code" href="../../da/df6/class_u_blox.html#afc846fbcb1cbd49057b5ce39cd0e0dd6">clearResponseBuff</a>();</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="../../da/df6/class_u_blox.html#a034c0463d1c199d094d657c8ebb151e8">uArt</a>.<a class="code" href="../../d9/d88/class_u_art.html#aa4818ca67447e251680b4b8d28c8bba5">readNext</a>(<a class="code" href="../../da/df6/class_u_blox.html#a6ca4b90f3dc4e856181dce1ebda6f82c">buffer</a>, <a class="code" href="../../d2/d67/_u_blox_8h.html#aad458adf8f40cbcc1074061f226a112e">AT_CMD_BUFF_LEN</a>, timeoutMs);</div><div class="line">}</div></div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="../../da/df6/class_u_blox.html#a4eaca5b1b1c4b5b6f6164b220dd43e0b">UBlox::readStatusResponse</a>(<span class="keywordtype">bool</span> crlf)</div><div class="line">{</div><div class="line">    <span class="comment">// Occasionally there are preceding \r\n; read and discard.</span></div><div class="line">    ssize_t rc = -1;</div><div class="line">    <span class="keywordflow">if</span> (crlf) {</div><div class="line">        rc = <a class="code" href="../../da/df6/class_u_blox.html#ab4a7ab4b8922d91e23f273ae160c1bed">readRawResponse</a>(<a class="code" href="../../db/d60/_u_blox_8cpp.html#ab6426fc74901f4fbec94862ebb672b81">RX_TIMEOUT</a>);</div><div class="line">        <span class="keywordflow">if</span> (rc != 2) {</div><div class="line">            <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Generically read the device response and attempt to resolve the status.</span></div><div class="line">    rc = <a class="code" href="../../da/df6/class_u_blox.html#ab4a7ab4b8922d91e23f273ae160c1bed">readRawResponse</a>(<a class="code" href="../../db/d60/_u_blox_8cpp.html#afed44347eb1fde151258e73004078c98">RX_TIMEOUT_STATUS</a>);</div><div class="line">    <span class="keywordflow">if</span> (rc == -1) {</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="../../da/df6/class_u_blox.html#aab6ad68e4c7522278f19ceab1dc2a58d">checkResponseBuffStatus</a>();</div><div class="line">}</div></div><!-- fragment --><p>The former merely clears (sets all elements to null terminators '\0') the buffer and reads the raw response, leaving the contents to be interpreted by the invoking function. The latter, however, implicitly invokes the former function with the addition of attempting to resolve the response (<a href="https://github.com/itsBelinda/ENG5220-2020-Team13/wiki/uBlox-and-CellLocate">OK, ERROR, or ABORTED</a>), consequently retuning a pointer to the state or nullptr in the event the status could not be resolved.</p>
<h3><a class="el" href="../../d7/d62/_u_art_8h.html">UArt.h</a> / .cpp</h3>
<p>Finally, at the bottom of the stack, the <a class="el" href="../../d7/d62/_u_art_8h.html">UArt.h</a> / .cpp files are responsible for managing the serial connection with the device. Thus, it implements the means by which commands are written to and read from the device.</p>
<p>First and foremost, the serial interface is initialised i.e. the device path (/dev/ttyS0) is opened and shortly configured using termios.</p><ul>
<li>Due to varying timeout durations associated with each command, VMIN and VTIME equal 0, thereby creating a non-blocking serial connection.</li>
</ul>
<h4>Reading</h4>
<p>Instead, commands are read utilising a polling based on the works posited on <a href="https://www.i-programmer.info/programming/cc/10027-serial-c-and-the-raspberry-pi.html">Serial C and The Raspberry PI</a>. While the interface <em>does</em> implement 'readExpected(...)' function for reading until blocks of known sizes, it is not utilised due to surrounding uncertainties of the environment (a premature ABORTED may be returned instead).</p>
<p>Thus, exploiting the format according to which responses are returned (<br />
 at the end of each response), the 'readNext(...)', the function permits variable sized blocks to be read.</p>
<div class="fragment"><div class="line">ssize_t <a class="code" href="../../d9/d88/class_u_art.html#aa4818ca67447e251680b4b8d28c8bba5">UArt::readNext</a>(<span class="keywordtype">char</span> * <span class="keyword">const</span> resultBuffer, <span class="keyword">const</span> <span class="keywordtype">size_t</span> resultBufferLen,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">int</span> timeoutMs)</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// Check that the device is present.</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="../../d9/d88/class_u_art.html#a61fb55cc7c92c85f2219dffcfb58bc12">device</a> == -1) {</div><div class="line">        <span class="keywordflow">return</span> -1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// The number of bytes that have been peeked and read.</span></div><div class="line">    <span class="keywordtype">size_t</span> bytesPeeked = 0;</div><div class="line">    ssize_t bytesRead = 0;</div><div class="line"></div><div class="line">    <span class="comment">// The next and last read indexes.</span></div><div class="line">    <span class="keywordtype">size_t</span> nextReadIndex = 0;</div><div class="line">    <span class="keywordtype">size_t</span> lastReadIndex = 0;</div><div class="line"></div><div class="line">    <span class="comment">// The last read character.</span></div><div class="line">    <span class="keywordtype">char</span> lastReadChar;</div><div class="line"></div><div class="line">    <span class="comment">// Timeout pause.</span></div><div class="line">    <span class="keyword">struct </span>timespec timeoutPause = {0};</div><div class="line">    timeoutPause.tv_sec = timeoutMs / 1000;</div><div class="line">    timeoutPause.tv_nsec = (timeoutMs % 1000) * 1000000L;</div><div class="line"></div><div class="line">    <span class="comment">// Keep reading the buffer until crlf.</span></div><div class="line">    <span class="keywordflow">for</span> (;;) {</div><div class="line"></div><div class="line">        <span class="comment">// If the buffer has been exceeded, return -1.</span></div><div class="line">        lastReadIndex = nextReadIndex;</div><div class="line">        <span class="keywordflow">if</span> (lastReadIndex &gt;= resultBufferLen) {</div><div class="line">            <span class="keywordflow">return</span> -1;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// If there are no characters within the buffer, sleep.</span></div><div class="line">        ioctl(<a class="code" href="../../d9/d88/class_u_art.html#a61fb55cc7c92c85f2219dffcfb58bc12">device</a>, FIONREAD, &amp;bytesPeeked);</div><div class="line">        <span class="keywordflow">if</span> (bytesPeeked &lt;= 0 &amp;&amp; nanosleep(&amp;timeoutPause, <span class="keyword">nullptr</span>)) {</div><div class="line">            <span class="keywordflow">return</span> -1;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// Read in a single character from the serial buffer.</span></div><div class="line">        bytesRead = read(<a class="code" href="../../d9/d88/class_u_art.html#a61fb55cc7c92c85f2219dffcfb58bc12">device</a>, &amp;lastReadChar, 1);</div><div class="line">        <span class="keywordflow">if</span> (bytesRead == -1) {</div><div class="line">            <span class="keywordflow">return</span> -1;</div><div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bytesRead == 1) {</div><div class="line"></div><div class="line">            <span class="comment">// Write the character to the buffer, check if &#39;\n&#39;.</span></div><div class="line">            resultBuffer[nextReadIndex++] = lastReadChar;</div><div class="line">            <span class="keywordflow">if</span> (lastReadChar == <span class="charliteral">&#39;\n&#39;</span>) {</div><div class="line">                <span class="keywordflow">break</span>;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Skip to the next character.</span></div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">// If no new bytes have been read and we have timed out, return.</span></div><div class="line">        <span class="keywordflow">if</span> (nextReadIndex == lastReadIndex) {</div><div class="line">            <span class="keywordflow">return</span> -1;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Return the number of characters that have been read.</span></div><div class="line">    <span class="keywordflow">return</span> nextReadIndex;</div><div class="line">}</div></div><!-- fragment --><p> Functionally, the 'readNext(...)' utilises C's nanosleep for inter-byte timeouts to sleep the thread until it is awoken due to the device responding with bytes; this state is entered in the event all characters have been read from the underlying Linux / device buffer (any bytes within the buffer will be immediately processed). Thus, the algorithm is functionally analogous to polling with the said nanosleep function providing the means by which inter-character timeouts are achieved.</p>
<h4>Writing</h4>
<p>**Assuming that the command conforms to the defined format i.e. ending in , the command can be written to the device by invoking the following function.** </p><div class="fragment"><div class="line">ssize_t <a class="code" href="../../d9/d88/class_u_art.html#aad1ddb133fe430a92527584eec2e674f">UArt::writeNext</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *command)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="../../d9/d88/class_u_art.html#a61fb55cc7c92c85f2219dffcfb58bc12">device</a> != -1 &amp;&amp; tcflush(<a class="code" href="../../d9/d88/class_u_art.html#a61fb55cc7c92c85f2219dffcfb58bc12">device</a>, TCIFLUSH) == 0) {</div><div class="line">        <span class="keywordflow">return</span> write(<a class="code" href="../../d9/d88/class_u_art.html#a61fb55cc7c92c85f2219dffcfb58bc12">device</a>, command, strlen(command) + 1);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> -1;</div><div class="line">}</div></div><!-- fragment --><p> Functionally, the function ensures that the device is present, flushes the data already written to the device and writes the command to the underlying device buffer. </p><h2>Running Program</h2>
<div class="image">
<img src="https://github.com/itsBelinda/ENG5220-2020-Team13/blob/master/doc/media/Running_Program.png" alt="The program executing successfully."/>
</div>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
